import math
def get_link_v(v,D):
    for i, weight in enumerate(D[v]):
        if weight>0:
            yield i

def arg_min(T, S):
    amin = -1
    m = math.inf  # максимальное значение
    for i, t in enumerate(T):
        if t < m and i not in S:
            m = t
            amin = i
    return amin

D = ((0, 0, 0, 0, 0, 11, 0),
     (10, 0, 10, 0, 0, 0, 0),
     (0, 0, 0, 13, 12, 0, 0),
     (0, 15, 0, 0, 0, 0, 0),
     (0, 0, 0, 0, 0, 0, 0),
     (0, 0, 0, 0, 12, 0, 8),
     (9, 0, 0, 0, 0, 0, 0))

N = len(D)  # число вершин в графе
T = [math.inf]*N   # последняя строка таблицы
v = 3      # стартовая вершина (нумерация с нуля)
S = {v}     # просмотренные вершины
T[v] = 0    # нулевой вес для стартовой вершины
while v != -1:          # цикл, пока не просмотрим все вершины
    for j in get_link_v(v, D):   # перебираем все связанные вершины с вершиной v
        if j not in S:           # если вершина еще не просмотрена
            w = T[v] + D[v][j]
            if w < T[j]:
                T[j] = w
    v = arg_min(T, S)            # выбираем следующий узел с наименьшим весом
    if v >= 0:                    # выбрана очередная вершина
        S.add(v)                 # добавляем новую вершину в рассмотрение
print(T)
